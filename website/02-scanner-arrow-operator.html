<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise 2: Adding the &#34;=&gt;&#34; Arrow Operator for Goroutines - Go Source Code Workshop</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-home">üöÄ Go Source Code Workshop</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <article class="exercise-content">
            <h1>‚ö° Exercise 2: Adding the &ldquo;=&gt;&rdquo; Arrow Operator for Goroutines</h1>

<p>In this exercise, you&rsquo;ll add a new &ldquo;=&gt;&rdquo; arrow operator to Go that works as an alternative syntax for starting goroutines! üöÄ This will teach you how to modify Go&rsquo;s scanner to recognize new operators and map them to existing functionality.</p>

<h2>üéØ Learning Objectives</h2>

<p>By the end of this exercise, you will:</p>

<ul>
<li>‚úÖ Understand how Go&rsquo;s scanner tokenizes operators</li>
<li>‚úÖ Know how to add new operator syntax to Go</li>
<li>‚úÖ Modify the scanner&rsquo;s lexical analysis logic</li>
<li>‚úÖ Test your scanner modification with working code</li>
<li>‚úÖ Successfully extend Go&rsquo;s operator vocabulary</li>
</ul>

<h2>üß† Background: How This Scanner Modification Works</h2>

<p>This exercise demonstrates <strong>scanner-level modifications</strong> to add new operator syntax to Go. We&rsquo;ll modify the scanner logic to recognize a new operator sequence &ldquo;=&gt;&rdquo; and map it to an existing token. Here&rsquo;s what we&rsquo;ll accomplish:</p>

<ul>
<li><strong>Scanner Enhancement</strong>: Add recognition for the &ldquo;=&gt;&rdquo; operator sequence</li>
<li><strong>Token Mapping</strong>: Map &ldquo;=&gt;&rdquo; to the existing <code>_Go</code> token (same as the &ldquo;go&rdquo; keyword)</li>
<li><strong>Alternative Syntax</strong>: Create <code>=&gt; myFunction()</code> as equivalent to <code>go myFunction()</code></li>
<li><strong>Minimal Impact</strong>: No parser or compiler changes needed - just scanner logic</li>
</ul>

<p>This approach allows us to create elegant alternative syntax without changing the deeper parts of the compiler!</p>

<h2>üîç Step 1: Navigate to the Scanner</h2>

<pre><code class="language-bash">cd go/src/cmd/compile/internal/syntax
</code></pre>

<h3>üîë Understanding the Scanner Structure</h3>

<p>Let&rsquo;s examine how the scanner handles the &ldquo;=&rdquo; operator in <code>scanner.go</code>. Look at line 325:</p>

<pre><code class="language-go">// go/src/cmd/compile/internal/syntax/scanner.go:325
case '=':
    if s.ch == '=' {
        s.nextch()
        s.tok = _Operator
        break
    }
    s.tok = _Assign
</code></pre>

<p>The scanner checks for &ldquo;==&rdquo; (equals comparison) first, then falls back to &ldquo;=&rdquo; (assignment).</p>

<h2>Step 2: Add the Arrow Operator Logic</h2>

<p>We need to add logic to recognize &ldquo;=&gt;&rdquo; and treat it as the <code>_Go</code> token.</p>

<p><strong>Edit <code>scanner.go</code>:</strong></p>

<p>Find the &ldquo;=&rdquo; case at line 325 and modify it to also check for &ldquo;&gt;&rdquo;:</p>

<pre><code class="language-go">// go/src/cmd/compile/internal/syntax/scanner.go:325
case '=':
    if s.ch == '=' {
        s.nextch()
        s.tok = _Operator
        break
    }
    if s.ch == '&gt;' {
        s.nextch()
        s.lit = &quot;=&gt;&quot;
        s.tok = _Go
        break
    }
    s.tok = _Assign
</code></pre>

<h3>üîß Understanding the Code Change</h3>

<ul>
<li><strong><code>if s.ch == '&gt;'</code></strong>: Check if the next character after &ldquo;=&rdquo; is &ldquo;&gt;&rdquo;</li>
<li><strong><code>s.nextch()</code></strong>: comsumes the &ldquo;&gt;&rdquo; character from the lexer</li>
<li><strong><code>s.lit = &quot;=&gt;&quot;</code></strong>: Set the literal value for debugging/error messages</li>
<li><strong><code>s.tok = _Go</code></strong>: Assign the same token as the &ldquo;go&rdquo; keyword</li>
<li><strong><code>break</code></strong>: Exit the case to avoid falling through to <code>_Assign</code></li>
</ul>

<h2>Step 3: Rebuild the Compiler</h2>

<p>Now let&rsquo;s rebuild the Go toolchain with our changes:</p>

<pre><code class="language-bash">cd ../../../  # back to go/src
./make.bash
</code></pre>

<p>If there are any compilation errors, review your changes and fix them.</p>

<h2>Step 4: Test the New Arrow Operator</h2>

<p>Create a test program to verify our new &ldquo;=&gt;&rdquo; operator works:</p>

<pre><code class="language-bash">mkdir -p /tmp/arrow-test
cd /tmp/arrow-test
</code></pre>

<p>Create a test.go file:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func sayHello(name string) {
    fmt.Printf(&quot;Hello from %s!\n&quot;, name)
}

func main() {
    fmt.Println(&quot;Testing =&gt; arrow operator...&quot;)

    // Test regular go keyword
    go sayHello(&quot;regular go&quot;)

    // Test our new =&gt; operator
    =&gt; sayHello(&quot;arrow operator&quot;)

    // Wait a bit to see output
    time.Sleep(100 * time.Millisecond)
    fmt.Println(&quot;All done!&quot;)
}
</code></pre>

<p>Execute the test program with your custom Go:</p>

<pre><code class="language-bash">/path/to/workshop/go/bin/go run test.go
</code></pre>

<p>You should see output like: ‚ú®</p>

<pre><code>Testing =&gt; arrow operator...
Hello from regular go!
Hello from arrow operator!
All done!
</code></pre>

<h2>üß™ Step 5: Test Mixed Go Operators</h2>

<p>Let&rsquo;s test mixed scenarios using both the traditional &ldquo;go&rdquo; keyword and our new &ldquo;=&gt;&rdquo; arrow operator:</p>

<p>Create a mixed-test.go file:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf(&quot;Worker %d starting\n&quot;, id)
    time.Sleep(50 * time.Millisecond)
    fmt.Printf(&quot;Worker %d done\n&quot;, id)
}

func main() {
    var wg sync.WaitGroup

    fmt.Println(&quot;Starting workers with mixed syntax...&quot;)

    // Mix of regular go and =&gt; operators
    for i := 1; i &lt;= 4; i++ {
        wg.Add(1)
        if i%2 == 0 {
            go worker(i, &amp;wg)  // Regular go
        } else {
            =&gt; worker(i, &amp;wg)  // Arrow operator
        }
    }

    wg.Wait()
    fmt.Println(&quot;All workers completed!&quot;)
}
</code></pre>

<p>Execute the mixed test program:</p>

<pre><code class="language-bash">/path/to/workshop/go/bin/go run mixed-test.go
</code></pre>

<h2>Step 6: Run Scanner Tests</h2>

<p>Let&rsquo;s make sure we didn&rsquo;t break the scanner:</p>

<pre><code class="language-bash">cd /path/to/workshop/go/src
../bin/go test cmd/compile/internal/syntax -short
</code></pre>

<h2>Understanding What We Did</h2>

<ol>
<li><strong>Modified Scanner Logic</strong>: Added &ldquo;=&gt;&rdquo; recognition to the existing &ldquo;=&rdquo; case</li>
<li><strong>Reused Existing Token</strong>: Mapped &ldquo;=&gt;&rdquo; to <code>_Go</code> token instead of creating new token</li>
<li><strong>Preserved Existing Functionality</strong>: &ldquo;=&rdquo; and &ldquo;==&rdquo; operators still work normally</li>
<li><strong>Minimal Change Impact</strong>: No parser or IR changes needed</li>
</ol>

<h2>üéì What We Learned</h2>

<ul>
<li>üî§ <strong>Scanner Logic</strong>: How Go tokenizes operator sequences</li>
<li>üìù <strong>Operator Recognition</strong>: Adding new operators through scanner modification</li>
<li>üîÑ <strong>Token Reuse</strong>: Mapping new syntax to existing tokens</li>
<li>üß™ <strong>Testing Strategy</strong>: Validating scanner changes with real code</li>
<li>üî® <strong>Build Process</strong>: Rebuilding Go with scanner modifications</li>
</ul>

<h2>üí° Extension Ideas</h2>

<p>Try these additional modifications: üöÄ</p>

<ol>
<li>‚ûï Add &ldquo;:&gt;&rdquo; as another alternative to &ldquo;go&rdquo;</li>
<li>‚ûï Add &ldquo;~&gt;&rdquo; for async operations</li>
<li>üî§ Add &ldquo;&gt;&gt;&gt;&rdquo; as a triple-arrow operator</li>
<li>üé® Make the arrow operator work in different contexts</li>
</ol>

<h2>‚û°Ô∏è Next Steps</h2>

<p>Great work! üéâ You&rsquo;ve successfully added a new operator to Go&rsquo;s scanner. You now understand how to modify the scanner to create alternative syntax for existing functionality. This technique can be applied to create other operator shortcuts and syntax sugar in the language.</p>

<p>In Exercise 3, we&rsquo;ll take a different approach and explore <strong>parser modifications</strong> - learning how to modify the parser to handle multiple consecutive tokens.</p>

<h2>Cleanup</h2>

<p>To restore the original Go source:</p>

<pre><code class="language-bash">cd /path/to/workshop/go/src/cmd/compile/internal/syntax
git checkout scanner.go
cd ../../../
./make.bash  # Rebuild with original code
</code></pre>

<h2>Summary</h2>

<p>The &ldquo;=&gt;&rdquo; arrow operator now works as an alternative to &ldquo;go&rdquo; for launching goroutines:</p>

<pre><code class="language-go">// These are now equivalent:
go myFunction()
=&gt; myFunction()

// Both create goroutines the same way!
</code></pre>

<p>This exercise demonstrated how scanner-level modifications can add new syntax with minimal code changes! üöÄ‚ú®</p>

<hr />

<p><em>Continue to <a href="03-parser-multiple-go.html">Exercise 3</a> or return to the <a href="index.html">main workshop</a></em></p>

        </article>

        <nav class="exercise-nav">
            
            <a href="01-compile-go-unchanged.html" class="nav-button">‚Üê Previous</a>
            
            
            <a href="03-parser-multiple-go.html" class="nav-button">Next: Exercise 3 ‚Üí</a>
            
        </nav>
    </div>

    <footer>
        <div class="container">
            <p>üöÄ Having Fun with the Go Source Code Workshop</p>
        </div>
    </footer>
</body>
</html>
