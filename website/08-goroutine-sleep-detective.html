<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise 8: Goroutine Sleep Detective - Runtime State Monitoring - Go Source Code Workshop</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-home">ğŸš€ Go Source Code Workshop</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <article class="exercise-content">
            <h1>ğŸ•µï¸â€â™‚ï¸ Exercise 8: Goroutine Sleep Detective - Runtime State Monitoring</h1>

<p>In this exercise, you&rsquo;ll modify the Go runtime scheduler to log goroutine state transitions! ğŸ” Every time a goroutine goes to sleep waiting for something, it will announce itself: &ldquo;Hello, I&rsquo;m goroutine 42, going to sleep waiting for channel receive&rdquo;!</p>

<h2>ğŸ¯ Learning Objectives</h2>

<p>By the end of this exercise, you will:</p>

<ul>
<li>âœ… Understand Go&rsquo;s goroutine scheduler state transitions</li>
<li>âœ… Know where goroutines block in the runtime</li>
<li>âœ… Modify the scheduler for debugging insights</li>
</ul>

<h2>ğŸ§  Background: Goroutine States</h2>

<p>Go manages goroutines through different states:</p>

<ul>
<li><strong><code>_Grunnable</code></strong> - Ready to run but not executing</li>
<li><strong><code>_Grunning</code></strong> - Currently executing</li>
<li><strong><code>_Gwaiting</code></strong> - Blocked waiting for something (our target!)</li>
<li><strong><code>_Gsyscall</code></strong> - Executing a system call</li>
<li>&hellip;</li>
</ul>

<p>When a goroutine needs to wait (for channels, mutexes, sleep, etc.), it &ldquo;parks&rdquo; and transitions to <code>_Gwaiting</code> state.</p>

<h2>ğŸ” Step 1: Understanding the Park Mechanism</h2>

<p>The <code>gopark</code> function is called by ALL synchronization primitives when a goroutine needs to wait.</p>

<pre><code class="language-bash">cd go/src/runtime
grep -n &quot;func gopark&quot; proc.go
</code></pre>

<p>Key functions:</p>

<ul>
<li><strong><code>gopark()</code></strong> - Initiates parking a goroutine</li>
<li><strong><code>park_m()</code></strong> - Actually changes the state to <code>_Gwaiting</code></li>
</ul>

<h2>Step 2: Find the State Transition Code</h2>

<pre><code class="language-bash"># Look at where the state actually changes
grep -n -A 5 &quot;func park_m&quot; proc.go
</code></pre>

<p>Around line 4237, you&rsquo;ll see:</p>

<pre><code class="language-go">casgstatus(gp, _Grunning, _Gwaiting)
</code></pre>

<p>This is the exact line where a goroutine transitions from running to waiting. Perfect for our logging!</p>

<h2>Step 3: Add Goroutine Sleep Logging</h2>

<p><strong>Edit <code>proc.go</code>:</strong></p>

<p>You&rsquo;ll need to add logging in three locations where goroutines transition to the waiting state:</p>

<h3>Location 1: <code>casGToWaiting</code> function (around line 1366)</h3>

<p>Find the <code>casGToWaiting</code> function and add logging after setting the wait reason:</p>

<pre><code class="language-go">func casGToWaiting(gp *g, old uint32, reason waitReason) {
	// Set the wait reason before calling casgstatus, because casgstatus will use it.
	gp.waitreason = reason
	if gp.goid &gt; 1 { // Skip system goroutines 0 and 1
		print(&quot;Hello, I'm goroutine &quot;, gp.goid, &quot;, going to sleep waiting for &quot;, gp.waitreason.String(), &quot;\n&quot;)
	}
	casgstatus(gp, old, _Gwaiting)
}
</code></pre>

<h3>Location 2: <code>casGFromPreempted</code> function (around line 1411)</h3>

<p>Find where preempted goroutines transition to waiting:</p>

<pre><code class="language-go">func casGFromPreempted(gp *g, old, new uint32) bool {
	// ... existing code ...
	if bubble := gp.bubble; bubble != nil {
		if gp.goid &gt; 1 { // Skip system goroutines 0 and 1
			print(&quot;Hello, I'm goroutine &quot;, gp.goid, &quot;, going to sleep waiting for &quot;, gp.waitreason.String(), &quot;\n&quot;)
		}
		bubble.changegstatus(gp, _Gpreempted, _Gwaiting)
	}
	return true
}
</code></pre>

<h3>Location 3: <code>park_m</code> function (around line 4240)</h3>

<p>Find the <code>park_m</code> function and add logging before the direct <code>casgstatus</code> call:</p>

<pre><code class="language-go">// Add this before: casgstatus(gp, _Grunning, _Gwaiting)
if gp.goid &gt; 1 { // Skip system goroutines 0 and 1
    print(&quot;Hello, I'm goroutine &quot;, gp.goid, &quot;, going to sleep waiting for &quot;, gp.waitreason.String(), &quot;\n&quot;)
}
casgstatus(gp, _Grunning, _Gwaiting)
</code></pre>

<h3>ğŸ”§ Understanding the Code</h3>

<ul>
<li><strong><code>gp.goid</code></strong> - Unique goroutine ID</li>
<li><strong><code>gp.waitreason.String()</code></strong> - Human-readable reason for waiting (channel, mutex, sleep, etc.)</li>
<li><strong><code>print()</code></strong> - Runtime print function (outputs to stderr)</li>
<li><strong><code>gp.goid &gt; 1</code></strong> - Skip system goroutines to reduce noise</li>
</ul>

<h2>Step 4: Rebuild Go Runtime</h2>

<pre><code class="language-bash">cd ../  # back to go/src
./make.bash
</code></pre>

<h2>Step 5: Test Channel Blocking</h2>

<p>Create a <code>channel_test.go</code> file:</p>

<pre><code class="language-go">package main

import &quot;time&quot;

func main() {
    ch := make(chan string)

    // Start goroutine that will block on receive
    go func() {
        msg := &lt;-ch  // Should trigger our logging!
        println(&quot;Received:&quot;, msg)
    }()

    // Let the goroutine start and block
    time.Sleep(100 * time.Millisecond)

    // Send something
    ch &lt;- &quot;Hello!&quot;
    time.Sleep(10 * time.Millisecond)
}
</code></pre>

<p>Build and run with our modified Go:</p>

<pre><code class="language-bash">../go/bin/go build channel_test.go
./channel_test
</code></pre>

<p><strong>Note:</strong> We build the binary first and then run it directly. This avoids mixing goroutines from the compiler/build process with goroutines from our program, giving us cleaner output!</p>

<p>Expected output:</p>

<pre><code>Hello, I'm goroutine 4, going to sleep waiting for GC scavenge wait
Hello, I'm goroutine 3, going to sleep waiting for GC sweep wait
Hello, I'm goroutine 2, going to sleep waiting for force gc (idle)
Hello, I'm goroutine 6, going to sleep waiting for chan receive
Hello, I'm goroutine 5, going to sleep waiting for GOMAXPROCS updater (idle)
Received: Hello!
</code></pre>

<p>ğŸ‰ You can now see goroutines blocking!</p>

<h2>Understanding What We Did</h2>

<ol>
<li><strong>Found the Park Function</strong>: Located where goroutines transition to waiting state</li>
<li><strong>Added Logging</strong>: Inserted print statement before state change</li>
<li><strong>Captured Wait Reason</strong>: Used <code>gp.waitreason.String()</code> for human-readable output</li>
<li><strong>Tested Scenarios</strong>: Verified with channels, mutexes, sleep, and select</li>
</ol>

<p>Common wait reasons you&rsquo;ll see:</p>

<ul>
<li><code>chan receive</code> / <code>chan send</code></li>
<li><code>sync mutex lock</code></li>
<li><code>sleep</code></li>
<li><code>GC</code></li>
</ul>

<h2>ğŸ“ What We Learned</h2>

<ul>
<li>ğŸ”„ <strong>Goroutine Lifecycle</strong>: How goroutines transition between states</li>
<li>ğŸ…¿ï¸  <strong>Park Mechanism</strong>: The <code>gopark</code> and <code>park_m</code> functions</li>
<li>ğŸ”’ <strong>Synchronization Internals</strong>: Where channels, mutexes, and select cause blocking</li>
<li>ğŸ› ï¸ <strong>Runtime Debugging</strong>: How to add observability to the Go runtime</li>
<li>ğŸ‘€ <strong>Concurrency Visibility</strong>: Real-time observation of blocking operations</li>
</ul>

<h2>ğŸ’¡ Extension Ideas</h2>

<p>Try these additional modifications: ğŸš€</p>

<ol>
<li>â• Add goroutine wakeup logging (when they resume running)</li>
<li>â• Add emojis for different wait reasons (ğŸ“¢ channel, ğŸ”’ mutex, ğŸ˜´ sleep)</li>
<li>â• Include timestamps to measure blocking duration</li>
<li>â• Filter logging by specific wait reasons only</li>
</ol>

<h2>Cleanup</h2>

<p>To remove the logging:</p>

<pre><code class="language-bash">cd go/src/runtime
git checkout proc.go
cd ../
./make.bash
</code></pre>

<h2>Summary</h2>

<p>You&rsquo;ve gained X-ray vision into Go&rsquo;s concurrency model! Your modified runtime now announces every goroutine blocking operation:</p>

<pre><code>Hello, I'm goroutine 18, going to sleep waiting for chan receive
Hello, I'm goroutine 19, going to sleep waiting for sync mutex lock
Hello, I'm goroutine 20, going to sleep waiting for sleep
</code></pre>

<p>This exercise revealed the internal workings of Go&rsquo;s scheduler and how synchronization primitives interact with the runtime! ğŸ•µï¸â€â™‚ï¸âœ¨</p>

<hr />

<p><em>Continue to <a href="09-predictable-select.html">Exercise 9</a> or return to the <a href="index.html">main workshop</a></em></p>

        </article>

        <nav class="exercise-nav">
            
            <a href="07-runtime-patient-go.html" class="nav-button">â† Previous</a>
            
            
            <a href="09-predictable-select.html" class="nav-button">Next: Exercise 9 â†’</a>
            
        </nav>
    </div>

    <footer>
        <div class="container">
            <p>ğŸš€ Having Fun with the Go Source Code Workshop</p>
        </div>
    </footer>
</body>
</html>
