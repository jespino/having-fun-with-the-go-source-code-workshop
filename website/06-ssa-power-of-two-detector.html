<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise 6: SSA Pass - Detecting Division by Powers of Two - Go Source Code Workshop</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="nav-home">üöÄ Go Source Code Workshop</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <article class="exercise-content">
            <h1>üîç Exercise 6: SSA Pass - Detecting Division by Powers of Two</h1>

<p>In this exercise, you&rsquo;ll learn how Go&rsquo;s SSA (Static Single Assignment) compiler passes work by creating a custom optimization pass that detects division operations by powers of two.</p>

<h2>üéØ Learning Objectives</h2>

<p>By the end of this exercise, you will:</p>

<ul>
<li>‚úÖ Understand Go&rsquo;s SSA compiler pass architecture</li>
<li>‚úÖ Know how to traverse SSA blocks and values</li>
<li>‚úÖ Create a custom analysis pass from scratch</li>
<li>‚úÖ Integrate your pass into the compiler pipeline</li>
<li>‚úÖ Use SSA dumps to verify your pass works</li>
</ul>

<h2>üß† Background: SSA Compiler Passes</h2>

<p>The Go compiler transforms your code through multiple passes:</p>

<ol>
<li><strong>Parse</strong> - Convert source code to AST</li>
<li><strong>Type Check</strong> - Verify types are correct</li>
<li><strong>IR Generation</strong> - Convert to IR (Intermediate representation) form</li>
<li><strong>SSA Generation</strong> - Convert to SSA (Static Single Assignment) form</li>
<li><strong>Optimization Passes</strong> - Transform SSA (our focus!)</li>
<li><strong>Code Generation</strong> - Produce machine code</li>
</ol>

<p>We are going to work with the SSA form to know about the posibility of optimizing powers of two.</p>

<h2>üîç Step 1: Understanding SSA Pass Structure</h2>

<p>SSA passes are registered in <code>compile.go</code> and operate on functions. Let&rsquo;s examine the structure:</p>

<pre><code class="language-bash">cd go/src/cmd/compile/internal/ssa
</code></pre>

<p>Open <code>compile.go</code> and search for <code>var passes</code> (around line 457). You&rsquo;ll see:</p>

<pre><code class="language-go">var passes = [...]pass{
	{name: &quot;number lines&quot;, fn: numberLines, required: true},
	{name: &quot;early phielim and copyelim&quot;, fn: copyelim},
	// ... many more passes
}
</code></pre>

<p>Each pass has:
- <strong>name</strong> - Displayed in debug output
- <strong>fn</strong> - Function that performs the transformation
- <strong>required</strong> - Whether this pass must run</p>

<h2>üîß Step 2: Create the Power of Two Detector Pass</h2>

<p>Create a new file to hold our detector pass:</p>

<pre><code class="language-bash">cd go/src/cmd/compile/internal/ssa
</code></pre>

<p><strong>Create <code>powoftwodetector.go</code>:</strong></p>

<pre><code class="language-go">package ssa

import (
	&quot;fmt&quot;
	&quot;math/bits&quot;
)

func detectDivByPowerOfTwo(f *Func) {
	count := 0

	for _, b := range f.Blocks {
		for _, v := range b.Values {
			// Check for division operations
			if v.Op == OpDiv64 || v.Op == OpDiv32 || v.Op == OpDiv16 || v.Op == OpDiv8 ||
				v.Op == OpDiv64u || v.Op == OpDiv32u || v.Op == OpDiv16u || v.Op == OpDiv8u {

				// Check if the divisor (second argument) is a constant
				if len(v.Args) &gt;= 2 {
					divisor := v.Args[1]

					// Check if it's a constant value
					if divisor.Op == OpConst64 || divisor.Op == OpConst32 ||
						divisor.Op == OpConst16 || divisor.Op == OpConst8 {

						constValue := divisor.AuxInt

						// Check if the constant is a power of two
						if isPowerOfTwo(constValue) {
							count++
							if f.pass.debug &gt; 0 {
								fmt.Printf(&quot;  [PowerOfTwo] Found division by power of 2: %v / %d (could be &gt;&gt; %d) at %v\n&quot;,
									v.Args[0], constValue, bits.TrailingZeros64(uint64(constValue)), v.Pos)
							}
						}
					}
				}
			}
		}
	}

	if count &gt; 0 {
		fmt.Printf(&quot;[PowerOfTwo Detector] Function %s: found %d division(s) by power of 2\n&quot;, f.Name, count)
	}
}
</code></pre>

<h3>üîç Understanding the Code</h3>

<ul>
<li><strong><code>f *Func</code></strong> - The SSA function being analyzed</li>
<li><strong><code>f.Blocks</code></strong> - All basic blocks in the function</li>
<li><strong><code>b.Values</code></strong> - All SSA values (operations) in a block</li>
<li><strong><code>v.Op</code></strong> - The operation type (division, addition, etc.)</li>
<li><strong><code>v.Args</code></strong> - Operands to the operation</li>
<li><strong><code>divisor.AuxInt</code></strong> - The constant value</li>
<li><strong><code>isPowerOfTwo()</code></strong> - Helper function that already exists in <code>rewrite.go</code></li>
<li><strong><code>bits.TrailingZeros64()</code></strong> - Calculates how many bits to shift</li>
</ul>

<h2>Step 3: Register the Pass in the Compiler</h2>

<p><strong>Edit <code>compile.go</code>:</strong></p>

<p>Find the <code>var passes</code> array (around line 457) and add your pass as the <strong>first</strong> entry:</p>

<pre><code class="language-go">var passes = [...]pass{
	{name: &quot;detect div by power of two&quot;, fn: detectDivByPowerOfTwo, required: true},
	{name: &quot;number lines&quot;, fn: numberLines, required: true},
	// ... rest of the passes
</code></pre>

<p>This runs your detector early in the pipeline, before other optimizations might eliminate the division.</p>

<h2>üìù Step 4: Rebuild the Compiler</h2>

<pre><code class="language-bash">cd go/src
./make.bash
</code></pre>

<p>This compiles your new pass into the Go compiler.</p>

<h2>üß™ Step 5: Create Test Programs</h2>

<pre><code class="language-bash">cd ../doing-it  # or your test directory
</code></pre>

<p>Create <code>test_divisions.go</code>:</p>

<pre><code class="language-go">package main

func testDivisions() int {
	x := 100

	// These should be detected (powers of 2)
	a := x / 2   // 2 = 2^1, could be &gt;&gt; 1
	b := x / 4   // 4 = 2^2, could be &gt;&gt; 2
	c := x / 8   // 8 = 2^3, could be &gt;&gt; 3
	d := x / 16  // 16 = 2^4, could be &gt;&gt; 4

	// These should NOT be detected (not powers of 2)
	e := x / 3
	f := x / 5
	g := x / 7

	return a + b + c + d + e + f + g
}

func main() {
	result := testDivisions()
	println(&quot;Result:&quot;, result)
}
</code></pre>

<h2>Step 6: Run and See the Detection</h2>

<pre><code class="language-bash">../go/bin/go build test_divisions.go
</code></pre>

<p><strong>Expected output:</strong></p>

<pre><code>[PowerOfTwo Detector] Function main.testDivisions: found 4 division(s) by power of 2
</code></pre>

<p>Your detector found the 4 divisions by powers of 2! üéâ</p>

<h2>Step 7: Test with Debug Output</h2>

<p>For detailed information about each detection:</p>

<pre><code class="language-bash">GOSSAFUNC=testDivisions ../go/bin/go build -gcflags=&quot;-d=ssa/detect div by power of two/debug=1&quot; test_divisions.go
</code></pre>

<p><strong>Expected output:</strong></p>

<pre><code>  [PowerOfTwo] Found division by power of 2: v10 / 2 (could be &gt;&gt; 1) at test_divisions.go:6
  [PowerOfTwo] Found division by power of 2: v14 / 4 (could be &gt;&gt; 2) at test_divisions.go:7
  [PowerOfTwo] Found division by power of 2: v18 / 8 (could be &gt;&gt; 3) at test_divisions.go:8
  [PowerOfTwo] Found division by power of 2: v22 / 16 (could be &gt;&gt; 4) at test_divisions.go:9
[PowerOfTwo Detector] Function main.testDivisions: found 4 division(s) by power of 2
</code></pre>

<p>This shows exact locations and shift amounts!</p>

<h2>üéì What We Learned</h2>

<ul>
<li>üèóÔ∏è <strong>SSA Pass Architecture</strong>: How to create and register compiler passes</li>
<li>üîç <strong>SSA Traversal</strong>: Walking through blocks and values to analyze code</li>
<li>üéØ <strong>Operation Detection</strong>: Identifying specific SSA operations</li>
<li>üìä <strong>Analysis vs Transformation</strong>: Our pass analyzes but doesn&rsquo;t modify (yet!)</li>
</ul>

<h2>üí° Extension Ideas</h2>

<p>Try these additional enhancements: üöÄ</p>

<ol>
<li>‚ûï <strong>Actually implement the optimization</strong>: Replace division with shifts</li>
<li>‚ûï <strong>Detect multiplication by powers of 2</strong>: Could use left shifts instead</li>
<li>‚ûï <strong>Count total optimizations</strong>: Track how many across entire build</li>
<li>‚ûï <strong>Report efficiency gains</strong>: Estimate cycle savings from the optimization</li>
</ol>

<h2>üßπ Cleanup</h2>

<p>To remove your custom pass:</p>

<pre><code class="language-bash">cd go/src/cmd/compile/internal/ssa
rm powoftwodetector.go
# Edit compile.go and remove your pass from the passes array
cd ../../src
./make.bash
</code></pre>

<h2>üìä Summary</h2>

<p>You&rsquo;ve successfully created a custom SSA compiler pass that detects optimization opportunities!</p>

<pre><code>Pass Name:     &quot;detect div by power of two&quot;
Input:         SSA function representation
Analysis:      Finds x / (power of 2) operations
Output:        Reports potential optimizations
Location:      Early in compiler pipeline

Example:       x / 8  ‚Üí  Reports: &quot;could be &gt;&gt; 3&quot;
</code></pre>

<p>This demonstrates how Go&rsquo;s compiler infrastructure allows custom analysis and optimization passes. Real optimizations use the same patterns - they just modify the SSA instead of only reporting! üöÄ‚ú®</p>

<hr />

<p><em>Continue to <a href="07-runtime-patient-go.html">Exercise 7</a> or return to the <a href="index.html">main workshop</a></em></p>

        </article>

        <nav class="exercise-nav">
            
            <a href="05-gofmt-ast-transformation.html" class="nav-button">‚Üê Previous</a>
            
            
            <a href="07-runtime-patient-go.html" class="nav-button">Next: Exercise 7 ‚Üí</a>
            
        </nav>
    </div>

    <footer>
        <div class="container">
            <p>üöÄ Having Fun with the Go Source Code Workshop</p>
        </div>
    </footer>
</body>
</html>
